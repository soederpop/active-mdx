# ActiveMDX for Software Development

ActiveMDX can help software development from the moment it is an idea for a software project, captured in a single file written in Markdown, until the moment it is fully developed and deployed in production. It helps that writing about software requirements is already a very structured activity, engaged in by people who are close enough to software developers to be familiar with writing in a structured way in general, or with markdown in particular.

In Agile software development, teams typically work in `Sprints`. A sprint consists of different people who are assigned `Stories`. Related `Stories` are grouped together under an `Epic`. As designers and developers complete work, they are delivered in `Releases` which get deployed to different `Environments` (e.g. dev, test, staging, production)

With ActiveMDX we can start writing about a software project in a single document. ActiveMDX can then help us turn that single document into epics and stories to help estimate, plan, and prioritize. Our designers and developers can read these to get a deep understanding of the problem domain, what is being built, and why.

With MDX and React, the designers and developers can actually enter their estimates into a form on a webpage generated by our writing, and these inputs will get captured back in the document. ActiveMDX will help us take all of this information and generate a proposal and a project plan for a client or investor to sign off on. As the team works through their sprints and makes releases, ActiveMDX can help us automatically generate release notes and status reports.

I will go through the process of developing the ActiveMDX `Models` to be able to do all of this.

First, take a look at the markdown below and notice it is structured with headings

```markdown
# Example E-Commerce Software Project

Some description and background. Can be as long as we want.

## User Roles

The User roles section will list out the different types of users that will use the software.

### Customers

Customers come to the site to learn about our products, and make purchases.

### Site Administrators

Site Administrators control the product catalog, images, and other content. They can also access customer orders.

## Epics

The epics section will have subheadings for the different groups of stories.

### Authentication

This covers everything related to user registration, signin, password recovery, etc.

### Payment Processing

This covers everything related to payment processing, including the payment gateway integration.

### Product Search and Browsing

This covers everything related to a user's journey browsing and searching for products.

### Order Lifecycle Management

This covers how orders are received, processed, and fulfilled.

### Content Management

This covers how the site's products are created, updated, etc.
```

This document is just an example, but the important thing to notice is the heading hierarchy

```
-Example E-Commerce Software Project
--Roles
---Customers
---Site Administrators
--Epics
---Authentication
---Payment Processing
---Product Search and Browsing
---Order Lifecycle Management
---Content Management
```

We can define a model for this

```javascript
import { Model } from "active-mdx"

export default class SoftwareProject extends Model {
  epics() {
    return this.hasMany("Epics")
  }

  userRoles() {
    return this.hasMany("UserRoles")
  }
}
```

If we had a dozen other projects, e.g.

- Example E-Commerce Project 2
- Example E-Commerce Project 3
- Social Network Project 1
- Social Network Project 2
- Business Portal App 1

We could build a database out of them with the [Collection Class](../guides/collections/README)

```javascript
import { Collection } from "active-mdx"
import SoftwareProject from "./models/SoftwareProject"

const portfolio = new Collection({
  rootPath: "projects",
  models: [SoftwareProject]
})
```

And query them like we would a database

```javascript
const myEcommerceProjects = SoftwareProject.query((qb) =>
  qb.where("name", "like", "%E-Commerce%")
)

const mySocialNetworkProjects = SoftwareProject.query((qb) =>
  qb.where("name", "like", "%Social Network%")
)
```

We could expand the single document into smaller documents, so they're easier to collaborate on and work with in detail

```javascript
const myProject = portfolio.getModel("projects/example-ecommerce-project-1")

await myProject
  .epics()
  .fetchAll()
  .map((epic) => epic.save())
await myProject
  .userRoles()
  .fetchAll()
  .map((userRole) => userRole.save())
```

This would create separate documents for each epic and user role, which we can also define models for

```javascript
export class Epic extends Model {
  static sections = ["stories"]

  get defaults() {
    return {
      meta: {
        status: "created"
      }
    }
  }

  get isComplete() {
    return this.stories()
      .fetchAll()
      .every((story) => story.isComplete)
  }

  stories() {
    return this.hasMany(Story, {
      heading: "stories",
      meta: () => ({ epic: this.title.toLowerCase() })
    })
  }

  static is(document) {
    return document.id.startsWith("epic")
  }
}

export default class Story extends Model {
  get defaults() {
    return {
      meta: {
        status: "created"
      }
    }
  }

  get isComplete() {
    return this.meta.status === "complete"
  }

  epic() {
    return this.belongsTo(Epic, {
      id: (document) => document.meta.epic
    })
  }

  get mockupLinks() {
    const { toString } = this.document.utils
    return Object.fromEntries(
      this.document
        .querySection("Mockups")
        .selectAll("link")
        .map((link) => [toString(link), link.url])
    )
  }

  get acceptanceCriteria() {
    const { toString } = this.document.utils
    return this.document
      .querySection("Acceptance Criteria")
      .selectAll("listItem")
      .map(toString)
  }
}
```

Each of these markdown documents, by themselves, can be used to present a webpage with a ton of useful information on it. If all anyone did was read them and treat them as documentation, they would be great by themselves.

But with ActiveMDX, we're able to treat each of these documents as things with names and identifiers that will easily relate with the rest of the software project's ecosystem. They can reference Tickets in software like Jira or Github Issues. They can be a part of a software services contract that you and a customer have an agreement on. The point is, there is an immense amount of value in this writing and ActiveMDX helps you unlock it and build applications for putting it to use.

## Next Steps

- [Generating a Scope of Work](/usecases/software-development/scope-example)
- [Building Story Status Dashboard](./story-status-dashboard.mdx)
